package org.leetcode.leet1000.ch800;

import java.util.ArrayList;
import java.util.List;

/**
 * <p>Ip到Cidr
 * 给定一个起始 IP 地址 ip 和一个我们需要包含的 IP 的数量 n，返回用列表（最小可能的长度）表示的 CIDR块的范围。
 *
 * <p>CIDR 块是包含 IP 的字符串，后接斜杠和固定长度。例如：“123.45.67.89/20”。固定长度 “20” 表示在特定的范围中公共前缀位的长度。
 *
 * <p>示例 1：
 * <p>输入：ip = "255.0.0.7", n = 10
 * <p>输出：["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
 * <p>解释：
 * <p>转换为二进制时，初始IP地址如下所示（为清晰起见添加了空格）：
 * <p>255.0.0.7 -> 11111111 00000000 00000000 00000111
 * <p>地址 "255.0.0.7/32" 表示与给定地址有相同的 32 位前缀的所有地址，
 * <p>在这里只有这一个地址。
 *
 * <p>地址 "255.0.0.8/29" 表示与给定地址有相同的 29 位前缀的所有地址：
 * <p>255.0.0.8 -> 11111111 00000000 00000000 00001000
 * <p>有相同的 29 位前缀的地址如下：
 * <p>11111111 00000000 00000000 00001000
 * <p>11111111 00000000 00000000 00001001
 * <p>11111111 00000000 00000000 00001010
 * <p>11111111 00000000 00000000 00001011
 * <p>11111111 00000000 00000000 00001100
 * <p>11111111 00000000 00000000 00001101
 * <p>11111111 00000000 00000000 00001110
 * <p>11111111 00000000 00000000 00001111
 *
 * <p>地址 "255.0.0.16/32" 表示与给定地址有相同的 32 位前缀的所有地址，
 * <p>这里只有 11111111 00000000 00000000 00010000。
 *
 * <p>总之，答案指定了从 255.0.0.7 开始的 10 个 IP 的范围。
 *
 * <p>有一些其他的表示方法，例如：
 * <p>["255.0.0.7/32","255.0.0.8/30", "255.0.0.12/30", "255.0.0.16/32"],
 * <p>但是我们的答案是最短可能的答案。
 *
 * <p>另外请注意以 "255.0.0.7/30" 开始的表示不正确，
 * <p>因为其包括了 255.0.0.4 = 11111111 00000000 00000000 00000100 这样的地址，
 * <p>超出了需要表示的范围。
 *
 * <p>注：
 * <p>ip 是有效的 IPv4 地址。
 * <p>每一个隐含地址 ip + x (其中 x < n) 都是有效的 IPv4 地址。
 * <p>n 为整数，范围为 [1, 1000]。
 * <p>@author: wangrui
 * <p>@date: 2021/3/24
 */
public class Ch751IpToCidr {

  public List<String> ipToCIDR(String ip, int range) {
    long x = 0;
    //获得一个ip地址每一部分
    String[] ips = ip.split("\\.");
    //将整ip地址看为一个整体，求出整体的int表示
    for (int i = 0; i < ips.length; ++i) {
      x = Integer.parseInt(ips[i]) + x * 256;
    }
    List<String> ans = new ArrayList<>();
    while (range > 0) {
      //求出二进制表示下的最低有效位的位数能表示的地址的数量
      //如果为奇数，则=1，即以原单个起始ip地址为第一块
      //如果为偶数，则二进制表示下的最低有效位的位数能表示的地址的数量
      long step = x & -x;
      //如果大于range，则需要缩小范围
      while (step > range) {
        step /= 2;
      }
      //不大于需要的range，开始处理
      //求出现在能表示的step个地址的地址块
      ans.add(longToIP(x, (int) step));
      //x加上以求出的地址块
      x += step;
      //range减去以表示的地址块
      range -= step;
    }//直到range<0
    return ans;
  }

  static String longToIP(long x, int step) {
    int[] ans = new int[4];
    //&255操作求出后8位十进制表示
    ans[0] = (int) (x & 255);
    //右移8位，即求下一个块
    x >>= 8;
    ans[1] = (int) (x & 255);
    x >>= 8;
    ans[2] = (int) (x & 255);
    x >>= 8;
    ans[3] = (int) x;
    int len = 33;
    //每一位就可以表示2个
    while (step > 0) {
      len--;
      step /= 2;
    }
    return ans[3] + "." + ans[2] + "." + ans[1] + "." + ans[0] + "/" + len;
  }

}
