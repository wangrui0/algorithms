package org.leetcode.leet500.ch300;

/**
 * <p> 258. 各位相加
 *
 * <p> 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。
 *
 * <p> 示例:
 *
 * <p> 输入: 38
 * <p> 输出: 2
 * <p> 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。
 *
 * <p> 进阶:
 * <p> 你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？
 *
 * @author: wangrui
 * @date: 2021/2/1
 */
public class Ch0258AddDigits {

  public int addDigits(int num) {
    while (num > 10) {
      int sum = 0;
      while (num > 0) {
        sum += num % 10;
        num /= 10;
      }
      num = sum;
    }
    return num;
  }

  /**
   * <p>1    1
   * <p> 2    2
   * <p> 3    3
   * <p>4    4
   * <p>5    5
   * <p> 6    6
   * <p> 7    7
   * <p> 8    8
   * <p> 9    9
   * <p> 10    1
   * <p> 11    2
   * <p> 12    3
   * <p> 13    4
   * <p> 14    5
   * <p> 15    6
   * <p> 16    7
   * <p>17    8
   * <p> 18    9
   * <p> 19    1
   * <p> 20    2
   * <p>根据上面的列举，我们可以得出规律，每9个一循环，所有大于9的数的树根都是对9取余，那么对于等于9的数对9取余就是0了，为了得到其本身，
   * <p>而且同样也要对大于9的数适用，我们就用(n-1)%9+1这个表达式来包括所有的情况。还有个特殊情况需要考虑一下，当num为0的时候，那么就会出现
   * <p>-1 % 9 的情况，这个其实挺烦人的，因为C++和Java会给出商0余-1的结果，而Python会给出商-1余8的结果，博主搜了一下，好像是说当有一个负数存在的时候，
   * <p>C++/Java会尽可能让商大一些，而Python会让商小一些，所以结果不统一就神烦，那么只好做个额外判断了，特殊处理一下0的情况就OK了，所以解法如下：
   *
   * @param num
   * @return
   */
  public int addDigits2(int num) {
    return (num == 0) ? 0 : (num - 1) % 9 + 1;
  }
}
